//! The C code used by the player.

use std::ffi::OsStr;
use std::io::{BufWriter, Write};
use std::path::Path;
use std::process::Command;

/// C code generator.
pub struct Generator<W>
where
   W: Write,
{
   output: BufWriter<W>,
}

impl<W> Generator<W>
where
   W: Write,
{
   /// Opens a new generator.
   pub fn new(output: W) -> Self {
      Self {
         output: BufWriter::with_capacity(4 * 1024 * 1024 * 1024, output),
      }
   }

   /// Generates the prelude.
   pub fn prelude(&mut self) -> anyhow::Result<()> {
      write!(
         self.output,
         r#"// “Dr. Szmelc is back, baby.”
// Generated by szmelc-player version {}
"#,
         env!("CARGO_PKG_VERSION")
      )?;
      Ok(())
   }

   /// Generates a `#define`.
   pub fn define(&mut self, name: &str, value: &str) -> anyhow::Result<()> {
      write!(self.output, "\n#define {} ({})", name, value)?;
      Ok(())
   }

   /// Generates an `#include`. If the given path string does not start with `"` or `<`, the quotes
   /// are added automatically.
   pub fn include(&mut self, path: &str) -> anyhow::Result<()> {
      if let b'"' | b'<' = path.as_bytes()[0] {
         write!(self.output, "\n#include {}", path)?;
      } else {
         write!(self.output, "\n#include \"{}\"", path)?;
      }
      Ok(())
   }

   /// Starts generating code for a constant byte array.
   pub fn const_byte_array(mut self, name: &str) -> anyhow::Result<ConstByteArray<W>> {
      write!(self.output, "\nconst unsigned char {}[] = {{", name)?;
      Ok(ConstByteArray { generator: self })
   }

   /// Generates the `main` function.
   pub fn main(mut self) -> anyhow::Result<()> {
      self.output.write_all(b"\n")?;
      self.output.write_all(MAIN.as_bytes())?;
      self.output.flush()?;
      Ok(())
   }
}

/// A generator for a constant byte array.
pub struct ConstByteArray<W>
where
   W: Write,
{
   generator: Generator<W>,
}

impl<W> ConstByteArray<W>
where
   W: Write,
{
   /// Adds a byte into the array.
   pub fn byte(&mut self, value: u8) -> anyhow::Result<()> {
      write!(self.generator.output, "{},", value)?;
      Ok(())
   }

   /// Finishes generating code for a constant byte array.
   pub fn finish(mut self) -> anyhow::Result<Generator<W>> {
      self.generator.output.write_all(b"};")?;
      Ok(self.generator)
   }
}

const MAIN: &str = r#"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

struct audio_context {
   ma_decoder decoder;
};

void audio_callback(ma_device *device, void *output, const void *input, uint32_t frame_count)
{
   struct audio_context *actx = device->pUserData;
   ma_decoder_read_pcm_frames(&actx->decoder, output, frame_count, NULL);
}

int main(void)
{
   struct audio_context actx = {0};

   ma_decoder_config decoder_config = ma_decoder_config_init(ma_format_s16, 2, AUDIO_SAMPLE_RATE);
   ma_decoder_init_memory((void *)audio_data, sizeof audio_data, &decoder_config, &actx.decoder);

   ma_device_config config = ma_device_config_init(ma_device_type_playback);
   config.playback.format = ma_format_s16;
   config.playback.channels = 2;
   config.sampleRate = AUDIO_SAMPLE_RATE;
   config.dataCallback = audio_callback;
   config.pUserData = &actx;

   ma_device device;
   if (ma_device_init(NULL, &config, &device) != MA_SUCCESS) {
      fprintf(stderr, "audio error: failed to initialize device\n");
      return -1;
   }

   ma_device_start(&device);

   printf("\e[2J\e[0;0H");
   for (size_t i = 0; i < VIDEO_FRAME_COUNT; ++i) {
      printf("\e[0;0H");
      for (unsigned y = 0; y < VIDEO_HEIGHT; y += 2) {
         for (unsigned x = 0; x < VIDEO_WIDTH; ++x) {
            size_t top_index = (i * VIDEO_WIDTH * VIDEO_HEIGHT + y * VIDEO_WIDTH + x) * 3;
            size_t bottom_index = (i * VIDEO_WIDTH * VIDEO_HEIGHT + (y + 1) * VIDEO_WIDTH + x) * 3;
            unsigned char
               top_r = video_data[top_index],
               top_g = video_data[top_index + 1],
               top_b = video_data[top_index + 2],
               bottom_r = video_data[bottom_index],
               bottom_g = video_data[bottom_index + 1],
               bottom_b = video_data[bottom_index + 2];
            printf(
               "\e[48;2;%i;%i;%im"
               "\e[38;2;%i;%i;%im"
               "▄",
               top_r, top_g, top_b,
               bottom_r, bottom_g, bottom_b
            );
         }
         printf("\e[0m\n");
      }
      usleep(SLEEP_INTERVAL);
   }

   ma_device_uninit(&device);
}
"#;

/// Compiles an executable using the given C compiler.
///
/// The compiler must be capable of accepting the following arguments:
/// - `-o <output-executable>`
/// - `-lm`
/// - `-lpthread`
/// - `-ldl`
pub fn compile_c(
   compiler: impl AsRef<OsStr>,
   input_file: &Path,
   output_file: &Path,
) -> anyhow::Result<()> {
   let compiler = compiler.as_ref();
   let mut cmd = Command::new(compiler);

   cmd.arg(input_file);
   cmd.arg("-o");
   cmd.arg(output_file);
   cmd.arg("-lm");
   cmd.arg("-lpthread");
   cmd.arg("-ldl");

   let extra_args: &[&str] = match compiler.to_str() {
      Some("gcc" | "clang") => &[
         "-Os",
         "-ffunction-sections",
         "-fdata-sections",
         "-Wl,--gc-sections",
      ],
      _ => &[],
   };
   println!("Passing {:?}-specific flags: {:?}", compiler, extra_args);
   // cmd.args(extra_args);

   let output = cmd.output()?;
   if !output.status.success() {
      anyhow::bail!(
         "C compilation failed:\n{}",
         String::from_utf8_lossy(&output.stderr)
      )
   } else {
      Ok(())
   }
}
