//! The C code used by the player.

use std::ffi::OsStr;
use std::io::{BufWriter, Write};
use std::path::Path;
use std::process::Command;

/// C code generator.
pub struct Generator<W>
where
   W: Write,
{
   output: BufWriter<W>,
}

impl<W> Generator<W>
where
   W: Write,
{
   /// Opens a new generator.
   pub fn new(output: W) -> Self {
      Self {
         output: BufWriter::with_capacity(4 * 1024 * 1024 * 1024, output),
      }
   }

   /// Generates the prelude.
   pub fn prelude(&mut self) -> anyhow::Result<()> {
      write!(
         self.output,
         r#"// “Dr. Szmelc is back, baby.”
// Generated by szmelc-player version {}
"#,
         env!("CARGO_PKG_VERSION")
      )?;
      Ok(())
   }

   /// Generates a `#define`.
   pub fn define(&mut self, name: &str, value: &str) -> anyhow::Result<()> {
      write!(self.output, "\n#define {} ({})", name, value)?;
      Ok(())
   }

   /// Starts generating code for a constant byte array.
   pub fn const_byte_array(mut self, name: &str) -> anyhow::Result<ConstByteArray<W>> {
      write!(self.output, "\nconst unsigned char {}[] = {{", name)?;
      Ok(ConstByteArray { generator: self })
   }

   /// Generates the `main` function.
   pub fn main(mut self) -> anyhow::Result<()> {
      self.output.write_all(b"\n")?;
      self.output.write_all(MAIN.as_bytes())?;
      self.output.flush()?;
      Ok(())
   }
}

/// A generator for a constant byte array.
pub struct ConstByteArray<W>
where
   W: Write,
{
   generator: Generator<W>,
}

impl<W> ConstByteArray<W>
where
   W: Write,
{
   /// Adds a byte into the array.
   pub fn byte(&mut self, value: u8) -> anyhow::Result<()> {
      write!(self.generator.output, "{},", value)?;
      Ok(())
   }

   /// Finishes generating code for a constant byte array.
   pub fn finish(mut self) -> anyhow::Result<Generator<W>> {
      self.generator.output.write_all(b"};")?;
      Ok(self.generator)
   }
}

const MAIN: &str = r#"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(void) {
   printf("\e[2J\e[0;0H");
   for (size_t i = 0; i < VIDEO_FRAME_COUNT; ++i) {
      printf("\e[0;0H");
      for (unsigned y = 0; y < VIDEO_HEIGHT; y += 2) {
         for (unsigned x = 0; x < VIDEO_WIDTH; ++x) {
            size_t top_index = (i * VIDEO_WIDTH * VIDEO_HEIGHT + y * VIDEO_WIDTH + x) * 3;
            size_t bottom_index = (i * VIDEO_WIDTH * VIDEO_HEIGHT + (y + 1) * VIDEO_WIDTH + x) * 3;
            unsigned char
               top_r = video_data[top_index],
               top_g = video_data[top_index + 1],
               top_b = video_data[top_index + 2],
               bottom_r = video_data[bottom_index],
               bottom_g = video_data[bottom_index + 1],
               bottom_b = video_data[bottom_index + 2];
            printf(
               "\e[48;2;%i;%i;%im"
               "\e[38;2;%i;%i;%im"
               "▄",
               top_r, top_g, top_b,
               bottom_r, bottom_g, bottom_b
            );
         }
         printf("\e[0m\n");
      }
      usleep(SLEEP_INTERVAL);
   }
}
"#;

/// Compiles an executable using the given C compiler.
///
/// The compiler must be capable of accepting an `-o <output-executable>` argument.
pub fn compile_c(
   compiler: impl AsRef<OsStr>,
   input_file: &Path,
   output_file: &Path,
) -> anyhow::Result<()> {
   let output = Command::new(compiler).arg(input_file).arg("-o").arg(output_file).output()?;
   if !output.status.success() {
      anyhow::bail!(
         "C compilation failed: {}",
         String::from_utf8_lossy(&output.stderr)
      )
   } else {
      Ok(())
   }
}
