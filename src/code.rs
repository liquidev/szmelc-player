//! The C code used by the player.

use std::ffi::OsStr;
use std::io::{BufWriter, Write};
use std::path::Path;
use std::process::Command;

/// C code generator.
pub struct Generator<W>
where
   W: Write,
{
   output: BufWriter<W>,
}

impl<W> Generator<W>
where
   W: Write,
{
   /// Opens a new generator.
   pub fn new(output: W) -> Self {
      Self {
         output: BufWriter::with_capacity(4 * 1024 * 1024 * 1024, output),
      }
   }

   /// Generates the prelude.
   pub fn prelude(&mut self) -> anyhow::Result<()> {
      write!(
         self.output,
         r#"// “Dr. Szmelc is back, baby.”
// Generated by szmelc-player version {}
"#,
         env!("CARGO_PKG_VERSION")
      )?;
      Ok(())
   }

   /// Generates a `#define` without a value.
   pub fn define(&mut self, name: &str) -> anyhow::Result<()> {
      write!(self.output, "\n#define {}", name)?;
      Ok(())
   }

   /// Generates a `#define` with a value.
   pub fn define_value(&mut self, name: &str, value: &str) -> anyhow::Result<()> {
      write!(self.output, "\n#define {} {}", name, value)?;
      Ok(())
   }

   /// Starts generating code for a constant byte array.
   pub fn const_byte_array(mut self, name: &str) -> anyhow::Result<ConstByteArray<W>> {
      write!(self.output, "\nstatic const unsigned char {}[] = {{", name)?;
      Ok(ConstByteArray { generator: self })
   }

   /// Generates the `main` function.
   pub fn main(mut self, replacements: &[(&str, &str)]) -> anyhow::Result<()> {
      let mut main = String::from(MAIN);
      for &(from, to) in replacements {
         main = main.replace(from, to);
      }
      self.output.write_all(b"\n")?;
      self.output.write_all(main.as_bytes())?;
      self.output.flush()?;
      Ok(())
   }
}

/// A generator for a constant byte array.
pub struct ConstByteArray<W>
where
   W: Write,
{
   generator: Generator<W>,
}

impl<W> ConstByteArray<W>
where
   W: Write,
{
   /// Adds a byte into the array.
   pub fn byte(&mut self, value: u8) -> anyhow::Result<()> {
      write!(self.generator.output, "{},", value)?;
      Ok(())
   }

   /// Finishes generating code for a constant byte array.
   pub fn finish(mut self) -> anyhow::Result<Generator<W>> {
      self.generator.output.write_all(b"};")?;
      Ok(self.generator)
   }
}

const MAIN: &str = include_str!("c/main.c");

/// Compiles an executable using the given C compiler.
///
/// The compiler must be capable of accepting the following arguments:
/// - `-o <output-executable>`
/// - `-lm`
/// - `-lpthread`
/// - `-ldl`
pub fn compile_c(
   compiler: impl AsRef<OsStr>,
   input_files: &[&Path],
   output_file: &Path,
) -> anyhow::Result<()> {
   let compiler = compiler.as_ref();
   let mut cmd = Command::new(compiler);

   cmd.arg("-o");
   cmd.arg(output_file);
   cmd.arg("-lm");
   cmd.arg("-lpthread");
   cmd.arg("-ldl");

   let extra_args: &[&str] = match compiler.to_str() {
      Some("gcc" | "clang") => &[
         "-Os",
         "-s",
         "-ffunction-sections",
         "-fdata-sections",
         "-Wl,--gc-sections",
      ],
      _ => &[],
   };
   println!("Passing {:?}-specific flags: {:?}", compiler, extra_args);
   cmd.args(extra_args);

   cmd.args(input_files);

   let output = cmd.output()?;
   if !output.status.success() {
      anyhow::bail!(
         "C compilation failed:\n{}",
         String::from_utf8_lossy(&output.stderr)
      )
   } else {
      Ok(())
   }
}
